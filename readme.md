Это - конспект доклада Евгения Борисова "Спринг-построитель" на онлайн-конференции JUG.RU от 17 мая 2020г.
Запись находится по адресу https://www.youtube.com/watch?v=rd6wxPzXQvo

#Введение

Цель данной работы - поближе познакомиться со Спрингом, получить понятия об основных концепциях IoC, посмотреть как работает Спринг изнутри.

Для этого напишем приложение "CoronaDesinfector".
В процессе написания возникнет необходимость написать инфраструктуру, которая позволит переиспользовать код, сделает код гибким. 
И, самое главное, поможет нам соблюсти все правила SOLID.
При дальннейшем развитии этой инфраструктуры у нас появится фреймворк, очень похожий  на Спринг.
Это поможет лучше понять Спринг не только как пользователь, но и как создатель.

Пишем на Java 11. Зависимости:
jsr-250 для аннотации PostConstruct,  
lombok для экономии времени
org.reflections - расширение стандартной Рефлекшн-Api
(в конце добавится CGLib)

*****
# Часть 1. Основные классы по ТЗ
Создадим 2 класса,  
    CoronaDesinfector
    Room

Дезинфектор по ТЗ выполоняет 4 действия:
    - Делает объявление, что сейчас начнется дезинфекция, всем покинуть помещение
    - Всем, кто не вышел сам, поможет полицейский
    - Собственно, дезинфекция
    - Объявление, что можно зайти обратно

Объявления будет делать специальный класс Announcer. 
Но на случай если мы захотим сделать разные виды объявлений, 
лучше сделаем интерфейс Announcer с методом announce(), и его реализацию ConsoleAnnouncer 

Полицейский тоже будет интерфейсом Policeman с методом makePeopleLeaveRoom(), 
и реализацией PolicemanImpl

в Дезинфекторе сделаем поля типа Полицейский и Анонсер, 
и назначим им по новому объекту соответствующих имплементаций.

в Main создадим экземпляр Дезинфектора и вызовем метод desinfect()
...Проверяем, все работает.

*****
# ЧАСТЬ 2. Cчитаем ответственности класса Дезинфектор.

Казалось бы, наш Дезинфектор отвечает только за дезинфекцию
Однако если присмотреться, single responsibility тут и не пахнет:
на данный момент у этого класса более 7 ответственностей

Кроме методов start() и desinfect() у нас тут 2 поля Announcer и Policeman, которые создаются здесь же. Annoouncer - это интерфейс, и, возможно, в будущем появятся и другие его имплементации. То есть класс CoronaDesinfector принимает решение, что именно ConsoleAnnouncer должен быть использован в качестве Announcer для данного приложения. Сейчас это решение захардкожено, но если появится логика, по которой нужно будет выбрать подходящую имплементацию, то вся эта логика будет находиться здесь же. Например, идет в ENVIRONMENT_VARIABLE смотрит locale чтобы узнать, в какой стране находится компьютер, на котором запущено наше приложение. Чтобы в зависимости от этого выбрать нужную имплементацию, которая говорит на нужном языке и в соответствии с законами и правилами этой страны. А это уже не имеет никакого отношения к дезинфекции.

Третья ответственностль - наш Дезинфектор также должен поимать, как именно должен создаваться Анонсер: сегодня это просто пустой корнструктор, а завтра этот конструктор поменяют и т.д. И придется пререписывать также и Дезинфектор.

- А еще наш Дезинфектор должен уметь настроить Анонсер.
  В данный момент это не требуется, но если завтра ConsoleAnnouncer обрастет пропертями (например, громкость)
  и их надо будет настраивать при помощи сеттеров и т.д... В этом случае ответственность за настройку лолжится на Дезинфектор.

Все то же самое касается и Полисмена.
Итого всего 7 ответственностей. И если завтра появится другая имплементация Анонсера, то нам нужно знать все то же самое про неё...

Если подытожить, нашему дезинфектору нужно
1) дезинфицирповать
2) уметь создавать объекты

А кто будет решать,каккая имплементация?  ...чуть окунемся в историю.
Раньше не было Contineous Delivery, и никто не заморачивался с поддержкой кода и версиями.
...
Потом появился паттерн Фабрика: AnnouncerFactory
и на каждый чих-пых писали свою фабрику:
PolicemanFactory, DesinfectorFactory..... FactoryFactory :)
..не годится.

# Часть 3. ObjectFactory

В дальнейшем вместо "new..." стали new писать синглетон ObjectFactory на все случаи жизни (тогда люди ещё не понимали, что синглетон это антипаттерн... см далее) 
Это еще не Spring, но его предтеча, поэтому и мы напишем ObjectFactory.

Создаем "домашний синглетон" (т.е. самописный) ObjectFactory:
    private static ObjectFactory $$instance = new ObjectFactory();

Добавим метод <T> T createObject (Class<T> type)
и теперь в Дезинфекторе вместо new Announcer() пишем
    ObjectFactory.getInstance().createObject(Announcer.class)

По сравнению с тем, что было, это выглялит замечательно, т.к. Дезинфектор не знает ничего конкретного ни про Анонсера, ни про Полисмена. Он знает, что они ему нужны Анонсер и Полисмен - но это интерфейсы. Он не знает, какая имплементация, как настроить и т.д. Об этом заботится Фабрика.

Но. В большинстве случаев в метод createObject(type) будет прилетать не конкретный класс, а интерфнйс. Поэтому надо сделать проверку....

    //в начале присвоим type - на случай, если нам приходит не интерфейс, а конкретный класс:
    Class<? extends T> implClass = type;

    //дальше проверка: если этот тип явл интерфейсом...
    if(type.isInterface()){ 

        //...то надо заменить. А на что?
        implClass = ???
            //....у кого мы можем это спросить?
            // Согласно SRP, Фабрика не должна отвечать за конфигурацию

            // Для этого сделаем специальный класс Config
            config.getImplClass(type);
    }

..., и если передали интерфейс, то достать тип из Конфига.

Cоздадим классы Конфиг (интерфейс0, и имплементацию JavaConfig. Он должен уметь получить type который скорее всего будет интерфейсом, и вернуть имплементацию. Предположим, что у нас только одна имплементация интерфейса на приложение. Идея такая: мы пишем приложение,которым будут пользоваться разные клиенты. Но на этапе сборки мы подложим jar, в котором могут быть имплементации, подходящие для одного конкретного клиента.
И когда все собирается, имплементация всегда одна - пока будем исходить из этого.

Для этого используем объект класса Reflections из пакета org.reflections
- он существенно расширяет возможности стандартного рефлекшна, а также отлично подходит для расширения стандартных возможностей Спринга.

Создается он через new Reflections(String packageToScan). Пакет для сканирования получим в виде строки
из конструктора Конфига.

Теперь каждый раз, когда Конфиг просят дать имплементацию какого-то интерфейса, используем метод 
    getSubTypesOf(ifc)
и если classes.size()!=1, то есть либо импл нет, либо больше одной
то продолжать не можем, бросаем ексепшн, а если проскочили этот if, то возвращаем 
    classes.iterator().next(); 

...всё, пока что Конфиг будет работать так.

Возвращаемся в ObjectFactory, там мы должны настроить наш конфиг, пока что - при создании захардкодим наш пакет (com.example)
    Config config = new JavaConfig("com.example");
А потом это не будет захардкожено, а будет приходить от человека, который создает контексты и прочие вещи

...запускаем, все работает.

# ЧАСТЬ 3.1 - улучшаем Фабрику: добавляем Мапу, в которую кешируем имплементации

...Теперь попробуемсоздать новую имплементацию Полисмена - AngryPoliceman.
Как и ожидалось, срабатывает условие "ноль или более одной имплементации"

Чтобы задать коркрктную имплементацию из нескольких, заведём в конфиге Мапу (или Мультимап, если в будущем захотим поддерживать множественные имплементации)

    private Map <Class, Class> ifcToClassImpl;

добавим в конструктор, и теперь в getImplClassaType() мы можем не бежать сканировать пакеты... Но сначала бы неплохо посмотреть в Мапе. В java 9 появилсся замечательный метод Map.computeIfAbsent()
Он принимает ключ, и если такой ключ существует, то возвращет значение по этому ключу.
Если ключа нет, то запускает лямбду, которая в конечном итоге возвращает значение,
которое засетится в Мапу на будущее, и заодно вернется к нам.


    ifcToClassImpl.computeIfAbsent(ifc, aClass -> {
        //эталямбдабудет запускаться в тот момент, когда в Мапе ничего (?) нет
    }); 
    кстати,поставим спереди return

Также с помощью этой Мапы мы экономим системные ресурсы, т к сканирование это дорогой процесс, и если мы уже один раз просканировали, то второй раз не придется искать.

вернемся в ObjectFactory - там у нас сломался вызов конструктора Конфига. Перенесем инициализацию в конструктор
    new JavaConfig("com.epam", new HashMap<>(Map.of(Policeman.class, AngryPoliceman.class)>))

на самом деле этот код в будущем не будет сидеть здесь
- эта мапа может строиться из какого-то внешнего конфигурационного файла -
  скрипта, xml. Который мы можем просканировать в рантайме, и построить эту мапу из информации,
  написанной в текстовом режиме.
  А если завтра мы захотим поменят имплементацию -
  например для тестов, или другого клиента -
  нам не придется чинить код.
  Просто подправим конфигурационный файл, из которого строится мапа

...запускаем,все работает

# ЧАСТЬ 4, настройка объектов, часть 1

Итак. У нас появилось централизованное место для создания всех объектов. Если мы заохтим подменить имплементацию, то поменяем класс, например, обратно на PolicemanImpl, запускаем - отрабатывает старый Полицейский. Причём это не изменения в коде, а изменения в конфигурации. Да, сейчас пока мы изменяем конфигурацию внутри, но в будущем мы выненсем ее наружу. Мы будем передавать конфигурационный файл, который будет считан в рантайме, и эта Мапа построится в рантайме.


Второй плюс- перед тем как Фабрика отдаст объект, она может его настроить согласно нашим конвенциям, которые мы придумкем в будущем:
-делать какие-то инжекшены,
-проксировать классы,
-делать транзакции,
-делать какое-то ООП...
..и много разной другой магии с объектом.

4.1 Для этого в методе createObject() отделим создание нового экземпляра и return

Для демонстрации полезной настройки разберем пример: 
Мы хотим чтобы каждый раз, когда ConsoleAnouncer выводит сообщение, он выводил еще и рекламу.
для этого заведем в нем Рекомендатор:
    Recommendator recommendator = ObjectFactory.getInstance().createObject()

4.2 Создадим интерфейс Рекомендатор с методом recommend, а также напишем реализацию RecommendatorImpl
Метод recommend() будет выводить строчку "для защиты от Короны пейте " + alcohol,
где alcohol - строка в RecommendatorImpl, которую мы хотим задавать при создании
пометим alcohol аннотацией @InjectProperty()
(аналог @Value в Спринге)
-здесь мы сделаем так, чтобы можно либо указать имя проперти которую надо инжектить,
-либо если имя не указано, то название поля будет именем этой проперти

4.3 Создадим класс этой новой аннотации, в ней можно будет задать value, но по дефолту ""

4.4 Теперь идем в Ресурсы и создаем файл application.properties (также как в Спринге)
добавим туда alcohol=beer corona

4.5. В ConsoleAnnouncer в метод announce добавляем вызов recommendator.recommend();

...проверяеем...
и получаем рекомендацию - пить Null
потому чтомы не написали парсер файла пропертей

# ЧАСТЬ 5. Парсер пропертей
(пока что навалим все в кучу, а потом отрефкторим)

**
итак, мы разделили создание объекта  и return. Перед тем как наша фабрика вернет объект, она должна его настроить. Т.е после того как объект создан (но перед тем как его вернуть), нам надо посмотреть - а нет ли у него каких-то полей, в которые мы моглибы заинжектить какие-то проперти. Без рефлексии не обойтись...

    implClass.getDeclaredFields()
    //по-хорошему надо найти также и поля родителя
    // а для этого нужна рекурсия или польз-ся какими-то ReflectionUtils
    // но сейчас для простоты сделаем без учета наследования

и для каждого филда попытаемся считать аннотацию
    
    Field field : implClass.getDeclaredFields()) {
        field.getAnnotation(InjectProperty.class);
        if(annotation!=null){
            if(annotation.value().isEmpty()){
                ..вытащить из файла проперти по названию поля 
            }
        }

**нам понадобится Мапа из файла проперти
**пишем парсер файла проперти

в цикле перебора полей -см выше- получим доступ к пропертиз
ClassLoader.getSystemClassLoader().getResources("application.properties")
в будущем мы можем усовершенствовать это,
и указывать также и доп файлы пропертей...хотя зачем?
в Спринге он читается автоматически, и всепро это знают

...берем Stream lines = BufferedReader(new FileReader(path из класслоадера)).lines()
lines.map(line->line.split("=").collect(toMap(arr->arr[0], arr->arr[1])))
это возвращает Map<String,String> propertiesMap =
и теперь отсюда мы можем доставать пропертис, если value в аннотации был пустой,
и вставлять их в строку

    String value;
    if ... {
        value= propertiesMap.get(field.getName());
    } else{
        valuie = propertiesMap.get(annotatipn.value())   
    }
можно сделать в виде тернарного оператора ("Элвис" :)

Если value в аннотации было пустое, то мы берем имя поля. А если значнеие было, берем его. Таким образом из мапы берем значение, которое нужно засетить. Правда, field скоорее всего привате, поэтому надосделать setAccessible(true), потом field.set (t, value)

..проверяем, работает, но...
//таймкод 54:00

# ЧАСТЬ 6 Рефактоирим Мапу и InjectProperty

..но. Некравсиво написан код: каждый раз читать проперти файл... Ну и вообще, страшно представить, что будет с фабрикой через несколько лет. Сегодня мы инжектим поля, завтра объекты, потом @Async, @Scheduled, @Transactional, @....,
и во всех них будем постоянно проверять и перебирать if'ы? Фабрика раздуется до тысяч строк, и другим людям придется допиливать вручную из сорсов...

В SOLID "O" означает открыто к дополнениям, закрыто для модификации. Если мы хотим дописать функционал, это не должно приводить к изменениям того, что уже написано. Сейчас наше "O" сломано: класс надо дописывать, и он никогда не будет "Close". А сломано оно потому что сломано "S" - single responsibillity. Они обычно ломаются вместе. Внашем случае - потому что Фабрика должна отвечать только за создание объекта, а у нас она также делает и его настройку. 

1. Настраивать надо в другом месте, поэтому делаем новый тип ObjectConfigurator (в Спринге это BeanPostprocessor). Это интерфейс, т.к. конфигураторов будет много: на каждую аннотацию, конвенцию, каждую дополнительную настройку
будет свой конфигуратор. У всех их есть метод configure(), который принимает Object t, не смотря на то, откуда он пришел, т к по его респоносибиолити не важно знать, откуда он пришел, и откуда он появился.

2. напишем его имплемментацию с длинным названием
    InjectPropertyAnnotaionObjectConfigurator
, и встатвим сюда логику из ObjectFactory. Правда нам откуда-то надо взять implClass - возьмем его из нашего объекта
    t.getClass()
(поставим @SneakyThrows)

3. Естественно что мапа не должна строиться каждый раз. Построим её один раз в конструкторе
Вспормогательные path, lines, на них propertiesMap.. А сама мапа должна быть филдом (иначе "пейте null")

итого, когда создастся Конфигуратор, он один раз просетит мапу.
и когда его попросят сконфигурировать объект, он будет смотреть -
а нету ли у полей данного объекта аннотации @injectPrerty?
и если есть, то будет доставать из propertyMap нужное значение для даной проперти
и сетить его в филд

осталось подружить ObjectFactory с Конфигураторами
4. в Фабрике: поле    private List<Configurator> configurators = new ArrayList<>();
как проинициализировать? чтобы не приходилось каждый раз куда-то прописывать эти Конфигураторы,
было бы неплохо просканировать наш пакет на предмет имплементаций Конфигураторов, точно также как мы сканируем имплементации для наших интерфейсов. А затем всехих учесть и сложть в Лист.

поэтому было бы неплохо,чтобы наш Конфиг умел отдавать Сканер
5.(делаем геттер в интерфейсе [через Refactor-Pull members up])
теперь наш Конфиг умеет не только говорить, какая имплементация, но и отдать Сканер, если какая-н инфраструктурная штука захочнт его получить. Причем этот сканер уже настроен: в Фабрику пришел готовый Конфиг. И когда этот Конфиг создается, он настраиваеи этот сканер на тот пакет, который попросили. И теперь этот настроеный сканер можнов любой момент получить

теперь наша ObjectFactory говорит: давайте у Конфига возьмеме Сканер, возьмем все подвиды ОбжектКонфигураторов, проитерируемся по ним (хорошо бы проверять,не абстрактный ли класс, но не сейчас)
    configurators.add(aClass.getDeclaratedConstructor().newInstance())

проверяем:
пейте null
(может выпасть, если не проинициализировалась Мапа; у меня было из-за того, что она пересоздавалась в конструкторе) 

Нет, забыли самое главное.
Мы проиниц лист конфигураторов, и в самом начале заполнили его. Но мы им нигде не пользуемся. Поэтому после создания объекта мы попросим каждый из конфигураторов настроить наш объект:
    configurators.forEach(objectCongfigurator->objectCpnfigurator.configure(t));

Это разновидность дизайн-паттерна "Chain of Responsibility": вместо того чтобы постоянно нарушать Open/Closed principle и постоянно добавлять логику, которая хэндлит какой-то объект, у нас есть много разных хэндлеров - в нашем случае Конфигураторов. И они автоматически добавляются в наш лист, и каждый имеет возможность настроить объект. Какие-то изних ничего не сделают, тк у объекта нет тех аннотаций, который они будут искать

И даже если какой-то объект совсем не надо настраивать, все равно мы можем без проблем протащить его хоть через 30 конфигураторов, т к большиснство объектов будут создаваться в начале (большинство изних - синглетоны). Поэтому на перформанс не сильно повлияет. А даже если и чуть-чуть повлияет, то на бутстрапе. А в рантайме, когда все объекты будут настроены и будут работать друг с другом, это вообще никак не затронет. Когда Дезинфектор работает, никакие фабрики не работают, он настроен и мы им пользуемся.

...проверяем, все работает.
>Корона бир, *реклама

...добавим в Пропертиз whisky=singleton
Пока мы не указали, какое проперти мы хотим заинжектить, будет то же самое. Решающим является название филда
филд "алкоголь" поэтому пропертиназ-ся "алкоголь",а в этом проперти сидит "корона бир"
если мы скажем @InkectProperty("whisky") то проинжектится проперти с этим именем

//таймкод 1:06:50
Промежуточные итоги: у нас есть централизованноеметсо длясощданиея объектов - Фабрика
Еслимыхотим помиенятьимплементаци,нам не надолезть в код
Если мы зотим чтобы объект приходил настроенным, мы модждем обучить Aff,hbre настроить нашлобъект согласноконвенциям типа "PropertySource"(?) ой то есть @InjectPropertyи т.д.
Мы сможем кэшировать синглетоны (пока не реализовано). Поскольку больштнство объектов от Фабрики - необъекты типа Person, аобхъектфы типа PersonService (сервисы, репозитории,контроллеры ит.д.) и эти сервисы в 99% слуячаевнудныв единстввенном экземпляре. Соответственно,их моженозакэшировать... Чем сейчас и займемся.

# ЧАСТЬ 7 Почему "домашний синглетон" это плохо?
(небольшая философская вставка)

Есть дата-объекты, они никогда не менеджатся таким фреймворком как Фабрика. Они менеджатся всякими Hibernate, Spring Data ит.д. Они никогда не бывают синглетонами, они постоянно создаются и наполняются разными данными из базы или по REST... 

А есть объекты, которые типа "сервисы", и эти сервисы лучше всего делать, что называется, "stateless". Это слово не означает, что у них нет стейта. "Stateless" означает, что когда сервис настроился - посредством конструктора, или сеттером, или проинжектили с помощью фреймворка - то потом его стейт уже не будет меняться. В таком случае их можно сделать синглетонами. Потому что мы можем не думать о том, что произойдет, если мой синглетон изменит состоние.

Если мой объект функционален, в нем есть разные функционалттные методы, которыми можно пользоваться в разных точках - зачем его клонировать? К томуже, есть случаи, когда клонирование будет бить по перформансу. Не говоря уже о случаях, когдаэто может банадльно наорушть бизнес-логику. Например, объекты типа Cache или LoadBalancer - их просто нельзя делать больше, чем один экземпляр.... Практически все наши сервисы должны быть синглетонами, т.к. если у нас одним сервисом пользуются разные классы, никто не долженн думать о том, что - я вот сейчас вызываю метод, а вдруг кто-то другой тоже, пользуясь эти синглетоном, его переконфигурировал в процессе? И у меня в процессе вызова что-то поменялось... Поэтому, если объект Stateless, я не должен думать про синхронизыцию, lock'и, и не придется его клонировать.  Поэтому Slateless нужно делать синглетоном.

...вернемся в наш CoronaDesinfector. 
Он не идеален,в первую очередь из-за части с getInstance() (Автор называет это Доашний Синглетон)
//таймкод 1:11:50
Когда кто-то хочет что-то получить от фабрики (а у нас Все хотят что-то получить от фабрики)
Что произойдетесли вдруг мызахотим переехать с Lomboka и декларировать эксепшены вместо @SneakyThrowws?
Все сломается.

Проблема №2. Хотим написат юнит-тест на CoronaDesinnfector.start() 
замокаем Анонсер ,Полисмена и т.д. (через Рефлекшнс) - но когда тест сделает new CoronaDesinfector(), в этот же момент дернется ObjectFactory.getInstance(), не смотря на то что мы мокаем наши поля, потому что перед конструктором отработают ^инлайны. То есть создастся Фабрика (при чем долго: вычитывает конфигурцию, сканирует пакеты, складываем в списки и мапы и т.д.). Но в работе это делается один раз. А вслучае с тестами это происходит при каждом тесте. Ну либо при помощи PowerMocka мокать getInstance()....а он работает еще медленнее,тк подменяет класслоадеры и пр.

Последний аргумент: мы говорили, что наша инфраструктура должна бы кэшировать снглетоны, т.к: "это классно, сервисы в большинствве должны быть синглетонами, все кто stateless должны быть синглетонами, нахрена плодить объекты, если можно  пользоваться одними и теми же..." Но! Если мы будем реалтзовывать синглетон как в 2003 году.... (а примерно с 2005 он счиатется анти-паттерном) Так почему не надо писать синглетон руками? Почему "Домашний С" это плохо? 

Представим, что пишем приложение с цепочкой зависимостей: A<-B, B<-C, C<-D и все они синглетоны, и вызывают друг друга через getInstance(). Вопрос: как будем тестировать? Никак, т к создание сервиса A притянет сервис B, который притянет сервис C, все это захардкожено... имеем длинный каплинг при помощи статических методов, взамен которых ничего не подложишь. Поэтому Синглетон это антипаттерн. Синглетон это хорошо, но Синглетон это плохо.

Поэтому, вместо того чтобы клонировать наше решение с getInstance() по всем классам и отказываться от фабрики, давайте наоборот - научим нашу инфрастркуктуру кэшировать все синглетоны.

# Часть 8. Введение в IoC, пишем @Autowired 

Сначала проыверим,что с Синглетоном проблема. Тоесть что сейчас их нет. Открывавем Анонсер,там есть рекомендатор. Завтра мы захотим рекомендатор заинжектить куда-то еще, придется еще раз дергать createObject(), создастся дополнительный инстанс. Мы хотим уйти от этого и где-то кешировать эти синлетоны.
Наверное для этого понадобится новая аннотация
для классов, которые хотят расскзать о себе,что они синглетоны.
@Singleton

А наша инфраструктура бюудет кешировать все объекты, помеченные этой аннотацией

В Спринге наоборот: по умолчанию все объекты явл синглетонами,
а если мы не хотим,надо рассказать при помощи аннотации @Scope
и указать что это- prototype или что...
(а вот в Google  Juice сделано как у нас, т е аннотацию @Singleton)

Но сначала... Мы хотим по прежнему поддерживать objectFactory в красивом состоянии. Если сейчас навесить доп респ-ти кэшировать объекты, это не очень. Для этого нужен другой уровень абстракции. 

1. Нужен новый класс, назовем его ApplicationContext. У него доступ к нашей ObjectFactory, куда он слазит если захочет создать объект. Еще у него будет Мапа<Class, Object> cache, в которой будут закешированы все созданные ранее объекты, которые явл-ся синглетонами (сделаем new ConcurrentHashMap)

2. Еще у Контекста будет метод <T> T getObject(Class<T> type) - это вмемсто create, т.к. мы не знаем, создастся ли новый иливернется ранее созданный. Пока ввернем null, потом допишем тело, а пока давйте подумаем. Что будет когда мы это закончим?  Мы помним,что в нашей инфрструктуре центром являлся ObjectFactory. И в некоторых местах у нас написано ObjectFactory.getInstance().createObject(...) Теперь  нам надо заменить этот код на Application.getBean(), то есть вместо createObject(), надотделать getObject(). А у нас,допустим,уже 800000строк кода написано с этим createObject(), куча клиентов  и опенсорс...

//Таймкод 1:20

Это называется "утечка инфраструктуры внутрь бизнес-логики". Неправильно, если наши сервисы бегают в инфраструктурный код и что-то просят для нас сделать. Если сервис знает как разговаривать с фабрикой, это значит чтоон на нее завязан. Он знает ее API, значит ее будет непросто поменять, непросто заменить на другую фабрику, или перейти на Spring, невозможно написать тесты. Огромное количество проблем.

Поэтому была придумана Инверсия контроля IoC.
IoC принцип Dont call us. We call you. Не вы будете дергать методы инфрстр, чтобы она настроила вам объекты. А она сама все создаст, поймет как настраивать и настроит. Точно также как в Рекамендаторе - можно было не инжектить проперти, а слазить в проперти файл руками,но вместо этого RecomendatorImpl в любом случае будет создаваться фабрикой. Фабрика cмотрит на аннотацию и понимает что надо заинжектить проперти. Тоже самое будем делать со всеми объектами-сервисами.

Вместо того чтобы настраивать поля самому, Дезинфектор попросит настроить эти поля у Фабрики. Поставим на все поля и создадим аннотацию @InjectByType (аналог @Autowired в Спринге). За эту аннотацию будет отвечать аналогичный конфигуратор
InjectByTypeAnnotationObjectConfigurator. 
В методе configure(t) надо все филды взять, проитерироваться, если присутствует аннотация, просетить филд.getTYpe().... Как его дальше создавать? Уж точно не через newInstance. Cкорее всего это интерфейс, а даже если нет, все равно он будет не настроен. Поэтому будем создавать через Фабрику:

setAccessible(true)
object = ObjectFactory.getInstance().createObject(fiueld.getType)
field.set(t, object)

Как только мы это написали, у нас уже все работает. За исключением одного - точки входа. Как только написали IoC, через new создавать объекты нельзя. Теперь в main Дезинфектор будет создаваться тоже через Фабрику ....createObject(CoronaDesinfewctor.class)

На минутку может показаться, что здесь у нас инфраструктура протекла в биз-логику. Но это всего лишь точка входа. А ObbjectFactory вызывается всего вдвух местах- в main и вметоде configure() которые тоже явл частью инфраструктуры.

...проверяем, все работает. Главное не забыть поставить Retention на аннотацию))

Взглянем на Дезинфектор. Очень чисто и красиво, только интерфейсы.
никаких тебе имплементаций, никакой инфраструктуры, только нужная бизнес логика

# ЧАСТЬ 9 Кешируем синглетоны часть 1
Давайте закончим с кешированием синглетонов. 

1. Идем в ApplicationContext, создаем поле Config config, который будет передаваться в конструктор. (напоминаю, что Конфиг содержит информацио о том, какие пакеты надо сканировать, и какие имплементации есть в мапе). Человек, который будет создавать конфигурацию, будет это передавать, и это все будет приходить в Контекст
//такмкод 1:29

2. В методе getObject надо сходить в наш кэш...но сначала обратим внимание на то, что в мапе cache первый параметр Class - это интерфейс. 

Нам придется сделать некоторые изменения в ObjectFactory, после чего Фабрику можно будет использовать только в Контексте. А больше никто другой с ней работать не будет. Идем в Фабрику в метод createObject() и убираем if (type.isInterface) {implClass = config.getImplClass()} - это то, что касается выбора имплементации, если тип переданного объекта явл интерфейсом. Почему убираем? Когда кто-то будет обращаться в контекст и говорить "мне нужен Полицейсский" - он будет давать интерфейс. Об этом интерфейсе должен знать Контекст, потому что именно он будет кешировать имплементацию, которую создаст Фабрика относительно этого интерфейса. Поэтому вырезаем первые 4 строки из createObject() и вставляем их в Контекст в getObject(). Теперь мы тут, если нас попросили достать объект, смотрим, не интерфейс ли это, если интерфейс, то вытаскиваем имплементацию 

3. Потом надо обратиться к мапе, и проверить - нет ли уже закешированной имплементации. Правда, это надо было делать в самом начале, когда к нам пришли с type
    if(cache.containsKey(type)){return (T) cache.get(type);}

И если в кеше нет, то надо создавать. Для этого см выше, проверить является ли type интерфейсом, и если да то конфиг расскажет, какая имплеменрация.

4. После того как создали, надо посмотреть, надо ли добавлять ее в наш кэш. Если на implClass стоит аннотация Singleton
сложим в кэш против type.
и вконце возвращаем этот t

//не совем понятно, почему мы складываем в кэш implClass, а возвращаем t
// типа при первом вызове все что @Singleton попадает в кеш, и более не создается
// этакий синглетон через кэш

//то есть у нас 2 ветки, t и type
//вернее даже 3
//первое - возвращаем cache.get(type), если есть
//второе - t создается через фабрику (перед этим, еcли type интерфейс, находим имплеметацию)
//третье - если имплементация является @Singleton, добавляем в кэш
// возвращает созданный объект t
//
// попахивает нарушением SRP?
// UPD потом мы что-то исправляли с вощвращаемым в этой функции..

еще раз:
1.Когда мы приходим в Контекст и просим объект определенного типа, например - интерфейс Полицейский
2.Котекст выясняет - может это Синглетон,который был ранее создан? забирай
3.если это 1) не синглетон и 2) синг,но еще не был создан
    a)найти имплементацию
    b) и дальше либо кешируем, нибо нет, в зависимости от того, синглетон иил нет
и в любом случае возвращаем

# ЧАСТЬ 10 Связываем Фабрику,Контекст и Конфигуратор, 
//Таймкод 1:32:40
чтобы все зарабртало,надо написать какой-то runner,
который будет связывать Фабрику и Конткест.
что за раннер такой?

наш К обязан зависеть от Ф, т.к. он создает объекты
с другой стороны, наша Ф обязана зависетьот К
почему?

1. идем в InjectByTypeCongfigurator (в Спринге - BeanPostProcessor), который отвечет за инжекшн. Если раньше инжектилось при полмощи фабрики, то теперь это тоже становится неправильно, т к если он инжектиит объект синглтон, то зачем его еще раз создавать? 
Вместо createObject() в надо делать Context.getObject()

2. Вопрос - откуда здесь в Конфигураторе появится Контекст? Напомним, что метод configure() вызывает Фабрика, когда она создала объект t из какакого-то конкретного класса. То есть, уже после того, как Контекст отправил конкреткую имплементацию. Мы её создали, настроили.. и в момент настройки вызываем configure(). И сюда уже должны передать Конткест, потому что как минимум один из Конфигураторов уже нуждается в этом Контексте (см выше getObject()). 
Т.е. в configure надо принимать также и ApplicationContext context, без которого мы не сможем создать объект

Не факт, что во всех Конфигураторах это надо, например, в InjectPropertyObjectConfigurator Конткст не нужен. Но пусть приходит, в интерфейсе пропишем, т к очень вероятно что будет нужен другим Конфигураторам. Или вдруг завтра у нас в Контексте будет сидеть какой-нибудь objectEnvironment, в котором будут находиться какие-то проперти, которые собрались в самом начале из переменных окружения и этот Конф тоже захочет слазить в Контект за ними, чтобы добавить их в Мапу. Так что неплохо Конфигуратору получать Контекст

/*1:36 реплика - в Контексте на 28 строке в кэш положили не то - надо t.
см выше было как раз непонятно. Т к кладем сингтон*/

3. Давайте чинить Фабрику
во-первых надо выкинуть Конфиг в конрструкторе
Он ей не нужен, потому что ей нужен весь Контекст, а в нем как раз есть Конфиг
и вообще удалим назначение переменной config, т к оно захардкожено
просто в Контексте сделаем геттер, и вместо config будем писать Контекст.getConfig()

4. Во-вторых, передадим Контекст в Конфигураторы после создания. Те Конфигкраторы, которые хотят сконфигурироать объект, имеют доступ к Контексту

5. ..только для начала конструктор Фабрики надосделать публичным (? почему, кстати)

6. во-вторых, этот контекст надо создать и засетить в конструкторе

7. ну и поскольку createObject теперь вызывается с имплементацией,мф можем переименовать type в implClass

# Часть 11, раннер
Итак, почему же нам нужен какой-то Раннер?
Надо в Контексте создать Фабрику
но при этом в нее саму надо передать Контекст, параметром которого должна быть this!
еще не отработал консьруктор Контекста, а уже начинает работать конструктор Фабрики.
непонятно чем это может закочится, особенно если при поднятии Контекста мы проинициализируем все синглтоны, которые не ленивые...уж точно ничем хорошим.

1. поэтому мы сделаем класс Application (В Спринге он называется SpringApplication) c методом run() который возвращает Контекст, и принимает строку packagesToScan и Мапу, в коротой <Class, Class> ifc2implClass. 
2. Из этого он строит Конфиг: new JavaConfig(...)
3. потом создает Контекст с этим конфигом: new ApplicationContext(config);
4. можем построить Фабрику, и передать в нее context вместо this
5. //todo homework: init all singletones which are not lazy:
   // скан пакетов, поискать @Singletone, сразу посоздавать объекты, сразу засунуть их в Контекст
6. И в конце надо засетить Контекст в Фабрику (для этого сделаем в Фабрике сеттер).
!! ой,наоборот: В контекст засетить Фабрику. сеттеры наоборот.

8. Теперь фабрика не создает себя сама (просто объявим переменую), и статический метод getInstance() большене нужен.   Да и переменную экземпляра можно тоже удалить из самой Фабрики. Больше ничего статического не осталось, как здорово! Есть обычный конструктор, в который передается Контекст, и после создания Фабрики засетим ее в Контекст (п.6 - сделали сеттер на экземпляре Фабрики в Контекте, а ранее созданный сеттер наоборот - удалим). Теперь можно сказать, что Контекст создан - вернем его, и выкинем евент "Context refereshed".

9. идем в Маин,и теперь вместо странного создания Дезинфектора возьмем его из Контекста,
который перед этим получим через Applicatioon.run(...), а параметрами передаем наш пакет и Мапу c интерфейсами-имплементациями (строка,которую мы ранее сохраняли)
// таймкод 1:43:50
...проверяем... 
Сломалось там, где мы создаем объекты через getInstance(), это как раз то о чем говорили ранее: чем позже переезжаем с lookup на IoC, тем больше чинить кода. Вместо getInstance делаем 
context.getObject()

...все работает.
//таймкод 1:44:30

# ЧАСТЬ 12: init-методы, @PostConstruct

Допустим мы хотим знать, сколько раз создается рекомендатор. Сделаем конструктор с выводом сообщения "recommendator was created". Сейчас он используется только один раз. Но если заинжектить в другой сервис - например, в Полицейского... 
1. добавим поле Recommendator recommendator (c аннотацией @InjectByType)
...и, достаточно лишь того, что он просто здесь создан... запускаем - ой, нет, недостаточно. Почему-то второй раз не создается...
2. Дело в том, что уже стоит аннотация @Singleton (^ не забыываем, что @Singleton ставится над телом класса). Для проверки сделаем наоборот - уберем эту аннотацию из RecommendatorImpl проверяем. Теперь соззлалсся 2 раза. Вернём синглетон обратно.

//Промежуточные итоги: на данном этапе мы вроде сделали IoC, Фабрика скрыта Контекстом,  в main мы просто создаем контекст, передав в него конфигурацуию, после - из Контекста вытащить объект.
И теперь нам не нужно писать домашний синглетон, а нужно просто поставить аннотацию

3. Но возникает следующая пролбема: допустим, Полисмен у себя в конструкторе хочет распечатать, какая конкретная имплементация интерфейса Рекомендатора ему заинжектилась (так,чисто для логов). Печатаем recommendator.getClass()..... и получаем NPE. Почему? Все вроде было ок, но когда перешли на IoC, почему-то получили в конструкторе NPE?

Дело в том, что createObject() состоит из двух этапов - создание и настройка. 
4. Кстати, вынесем в методы эти этапы - (^выделить стрноку, Extract method]), итак полуучается 1й этап - create(), 2й этап - настройка configure() 

Напомним, что на 1 этапе вызывается конструктор. А наш фреймворк не использует constructor injection т.е. мы не передаем в конструктор все наши зависимости, а вместо того сеттим их потом по филдам. Соответстно, на том этапе, когда работают консторукторы, еще ничего не проинжектилось. Поэтому, если в конструкторе код пытается работать с тем, чего еще нет... "Нельзя воспитывать ребенка, пока он не родился", нельзя настраивать объект, пока он не создался, т.е. не отработал консторуктор. Что мы можем сделакть?

Во-первых, сам мир IoC предполагает, что мы редко будем писать что-то в конструкторе. Да и вообще, обычно в конструкторе настраивают объекты, а у нас они настраиваются фреймворком - Контекстом, Фабрикой, Конфигураторами. Но не исключено, что иногда все же кто-то иногда будет поднастраивать под себя что-то, чем фреймворк не занимается. Получается, что нам надо отказаться от использования конструкторов.

//Таймкод 1:49:20
5. Надо использовать init-метод. Просто переименуем конструктор в метод init(). Проблема в том, что его нам никто не запустит, таким образом мы подходим к новыой концепции, которая называется "second-face constructor", т.е. вторичный конструктор

6. В мире IoC есть концепция init-кода, который надо прогнать после того, как объект уже настроен. Не как с конструктором, когда он только создан, а когда уже настроен. Для этого уже придумали конвенцию, что все такике методы будут помечаться @PostConstruct. Нам тоже надо написать поддержку такой аанотации

7. Идем в Фабрику. Следующим шагом после configure() итерируемся по implClass.getMethods()
    если method.isAnnoptationPresent(PostConstruct.class){
        method.invoke(t);// где t - объект, на котором запускаем этот метод
    }
}

8. Для читабельности выделим это в отдельный метод invokeInit(). Однако прежде чем прождолжить, давайте пофантазируем, где этот метод должен находиться. Варианты такие:

a) остаться в фабрике
b) Создать еще один конфигуратор
c) создать новый тип конфигураторов, например PostConstructInvoker....

Правильный ответ - "a", потому что наша задача находиится в зоне ответственности Фабрики, т.к. ее респонсибилити это создавать объект, что означает - запускуать его конструктор. Метод @PostConstruct - это вторичный конструктор. Нет никакой причины, почему нужно выносить в какой-то конфигуратор.  Конфигураторов может быть много разных, но конфигуратор, вызывающий init-методы, должен быть явно один. Поэтому никакой новый тип создавать не имеет смысл. А засовывать это в конфигуратор будет очень серьезная проблема. Дело в том, что запускать init-метод надо после того, как объект уже настроен. Если за вызов init-метода будет отвечать один из конфигураторов, то он обязательно
должен быть последним по порядку. А мы не хотим, чтобы порядок вызовов для нас стал важным.

Кстати, давайте посмотрим как это сделано в Сприге (возьмем любой проект со Спрингом, ну или добавим на минуточку в депенденси Спринг-контекст). Смотрим в конфигураторы, напнример CommonAnnotationBeanPostProcessor... А что это за переменная order??? Получается, у разных конфигураторов разный порядок, в Спринге пошли по второму сценарию... (Йорген Колер объясняет это своей неопытностью во времена написания Спринга). Мы же останемся на первом. Потому что Фабрика отвечает за создание объекта, и нет никаких проблем, чтобы Фабрика дернула вызов инит-метода, потому что можно рассматривать его как продолжение конструктора

..проветяем, все работает [1:54:30]

# ЧАСТЬ 13, Прокси часть 1

Теперь допустим, что класс RecommendatorImpl стал @Deprecated, и мы хотим, чтобы при вызове всех методов всех классов, помеченных @Deprecated, печаталось сообщение. Если обобщить, мы хотим менять поведение работы методов, не меняя их тело. В нашем случае метод recommend() будет работать по старому, но перед ним или после него делаем в дополнение что-то еще.

В отличие от PostConstruct мы не настраиваем объект только один раз, а теперь при каждом вызове нам нужно изменять поведение метода. Как это сделать?

Уж точно, не инструмнтируя код - это будет очень сложно: т.к. наш фреймворк работает в рантайме,
и придется ^подключаться агентами на бутстрапе, или на этапе компиляции, и как-то аспектировать наши классы^

Поэтому мы воспользуемся паттерном Прокси. Он широко используется в случаях, когда надо добавить дополнительную логику в метод, но при этом нет возможности этот метод поменять (например, если это не наш класс). В этом случае мы можем подменить объект на другой, соответствующий по типу - вместо recommendatorImpl мы подсунем recommendatorShmimpl, который имплементирует тот же интерфейс, поэтому его подмену никто не заметит. В этом случае наша фабрика вместо recommendatorImpl вернет объект Proxy. 

Существует 2 распространенных способа сделать прокси: встроенный Java API - dynamic proxy, а также библиотека CGLib, которая делает прокси при помощи наследования. 

Начнем с первого, dynamicProxy. Допустим, у нас есть интерфейс Ifc с методами a() и b(int), и наша имплементакция IfcImpl которая принимает то же самое. С 1999 года в Java существует библиотека DynamicProxy  которая может создать класс на лету. На выходе получаем прокси-класс с теми же методами, и тем же типом данных на выходе - нужно только рассказать, какие интерфейсы он должен имплементировать.

1. Идем в Фабрику, берем Proxy.newProxyInstance(). Название метода говорит нам, что он не только сгененит класс, но и создаст из него объект, который мы и подложим. В этом Прокси-классе тоже будут методы a() и b(int) - а откуда он про них знает? а оттуда, что мы передадим кое-что в метод: первым параметром будет Класслоадер (нам сейчас не важно, возьмем из implClass.getClassLoader()),
а второй параметр - это интерфейсЫ, которые наш класс должен имплементиоровать implClass.getInterfaces(), а также обязательно третьим параметром InvocationHandler - можно анонимный
new InvocationHandler{...} , у которого есть метод invoke(Method method, Object[]  args){}
(..?) и как реализованы методы a() и b(int) - абсолютно точно также.

Получается, что проски-класс, когда у него вызывают метод, передает вызванный метод и аргументы в InvocationHandler, который может добавлять какую-то логику, например, печатает строку, как мы того и хотели, а потом вызывает соответствующий метод в нашей исходной имплементации method.invoke(t, args ) и возвращает его. Внимание, метод вызываем у t, не у прокси! 

2. обернем всю полученную конструкцию в if (...@Deprecated), и вернем из Фабрики либо наш только что созданный с помощью newProxyInstance() объект, либо t без изменений, если нет аннотации @Deprecated

...проверяем... 
//Автоматически импортировалась библ CGLIB, а надо java.reflect.proxy...тогда заработает. 

Каждый раз, когда вызывается метод Депрекейтнутого класса, перед этим печатается наше сообщение. При чем, когда Прокси срабатывает, в нашем логе он фигурирует как "Proxy6" или что-то вроде того

//Таймкод 02:05:00
Резюмируем: есть 2 варианта, кто запрашивает объекты от нашего фреймворка: либо делаем lookup (у нас это только в одном месте - в main(), когда мы просим context.getObject(..). Либо аннотация @InjectByType спровоцирует Конфигуратор пойти в Контекст и достать оттуда объект, подходящий под этот тип. А Фабрика возвращает не имплементацию, а Proxy. Удлинняется цепочка, производительность чуть-чуть падает. Зато появляется настоящее АОП (^аспекты?), которая дает возможность делать что-то до, после, или даже вместо вызова метода, или даже вовсе не вызывать метод (как например в Спринг ^Security)

Оставлять код так некрасиво, надо перетащить... а вот куда? Наш Announcer раньше вызывал recommend() у RecommendationImpl, теперь механизи инжекшена вытащил из Фабрики объект Прокси, который делегирует вызов метода InvocationHandler'у. Который и вызывает метод у RecommendationImpl. Как и в прошлый раз, у нас есть варианты: оставить в Фабрике, перенести в еще один Конфигуратор, создать новый тип конфигураторов. Мы создадим новый вид конфигураторов. 

/*Кстати, Спринг делает это в Конфигураторе. Вообще в Спринге много странных решений - например, в BeanPostProcessor (у нас - ....TODO) почему за конфигурацию отвечает BeanPostProcessor? почему такой сложный ордеринг? Йорген Колер отвечает, что просто это было написано очень давно (2002г), когда еще особо не были приняты дизайн-паттерны...*/

Почему будет более правильно создать новый вид конфигураторов? А не, например, созлать еще один ObjectConfigurator? Во-первых, ОбжектКонфигуратор ничего не возвращает - а нам надо возвращать Прокси (и Object в конфигураторе возвр не будем).

В Спринге просто сделали еще один метод в интерфейсе ObjectConfigurator. А мы сделаем новый интерфейс,
потому что 4е правило SOLID (...? TODO) говорит, что не надо делать "толстый" интерфейс, поэтому мы сделаем "тонкий" интерфейс.

Создаем интерфейс ProxyConfigurator, и с его помощью будем делать всякие разные штуки, где надо подменять логику: транзакции, асинхронные методы... Там метод Object replaceWithProxyIfNeeded(), который принимает объект который надо сконфигурировать. Также этот метод должен принимать implClass, но почему? Ведь мы можем взять implClass из объекта? Не всегда. Если будет цепочка прокси, getClass() будет возвращать Proxy6, а в нем нет оригинальных аннотаций.

3. Делаем класс DeprecatedHandlerProxyConfigurator, вставляем туда логику (без кастинга, кастинг оставим в Фабрике). 
4. Идем в Фабрику, точно также как с ObjectConfigurator делаем лист ПроксиКонфигураторс, 
5. точно также находим все ПроксиКонфигураторы, 
6. в конце итерируемся по этому листу, и в каждой итерации  заменяем t на результат работы метода ПроксиКонфигуратора (кастинг сделаем тут). 
7. Вынесем в отдельный метод wrapWithProxyIfNeeded() название конечно спорное, т.к. можно и конфигуратор назвать "...ifNeeded", но именно здесь это важно подчеркнуть, т.к многим почему-то кажется, что объект проксируются в любом случае.

//Еще - ранее забыли в методе create() вернуть T вместо Object

...проверяем, работает.. Если убрать @Deprecated, проксироваться не будет

# ЧАСТЬ 14, CGLib

Что бы было, если бы мы вызвали @Deprecated метод в классе, в котором нету интерфейсов, например в CoronaDesinfector? Падает с ClassCastException, почему?

Если стоит аннотация, он обязательно попадет в наш ПроксиКонфигуратор. Там его спросят, какие есть интерфейсы? Никаких. Ок, там создастся прокси, который не имплементирует ниаких итерфейсов. То есть класс, у которого нет методов.

Но падает еще раньше - в Main - оттого, что класс, который мы получили от Фабрики, пытаемся закастить в CoronaDesinfector, а получили какой-то Proxy$7, не имеющий ничего общего с Дезинфектором, и даже вообще не имеющий методов.

Вот если бы Проски-класс создался не при помощи интерфейсов, а при помощи наследования, всё бы получилось.

Добавим библиотеку CGLIB, которая предоставляет API похожий на dynamic proxy, но позволяет проксироваться через наследование.

Идём в if(@Deprecated), здесь мы уже точно знаем, что будем проксироваться желательно через интерфейсы. Но вдруг их нету?  if(getInterfaces().length == 0){
        //в Спринге сделано еще круче: если даже и есть интерфейсы, но на них нет методов
        // например, если мы отнаследовали пустой интерфейс типа Serializable
        return Enhancer.create(implClass, new cglib.proxy.InvocationHandler(){
        });
//Enhancer - класс из CGLIB. Причем CGLIB почти всегда есть в почти любой библиотеке
//тут все то же самое что в DynamicProxy

В обиех частях, где new InvocationHandler, сделаем лямбду, и инкапсуклируем ее в отдельный метод getInvocationHamdlerLogic() <Alt+Ctrl+M>. Потом можно каждый выхов этого метода тоже 

[2:17?]

проверяем - всё работает

# HOMEWORK 1, @Deprecated methods support

Напоследок надо сказать, что логика invocationHandler не всегда дложна быть такой тупой
например, @Deprecated может быть не только класс, а например только метод. Как это сделать? Сейчас наш invocationHandler тупой, он просто добавляет println перед вызовом. А по факту должен бы проверять приходящий к нему метод - @Deprecated он или нет.

В качестве ДЗ сделаем это:
член List <Method> deprecatedMethods
вконце где мы обошли все if'ы и возвращаем t (то есть когда на классенет аннотации @Deprecated), пред этим сделаем перебор всех методов, если какие аннотированы, добаваляем их в Лист. 
И затем еще одно условие, если лист пустой, возвращаетм t, инае делаем прокси, и в InvocationHandlere проверяем метод на наличие аннотации.   

#
#
#
# ЗАКЛЮЧЕНИЕ

Итоговая картина Фабрики такая:

T t = createoObject(implClass);
configure(t);
runInitMethod(implClass, t);
t=replaceWithProxyIfNeeded(t, implClass);
return t;

И вот примерно так работает Спринг. Здесь не показано все точто свяано с Контекстом - что кешируется, что резолвится имплементация, что идет работа сконфигурацией. Тут мы видим, как строится объект: сначала просто создается
причем в Спринге он может еще и создаваться так, что в конструктор уже засунуктся какие-то вещи, которые надо зианжектить.
Потом он в любом слечае настраивается всякими разными разными конфигураторами, которые могут проинжектить в него разные дополнитеотнфые вещи. Потом запускается инит-метод. И потом он проходит еще по цепрочке прокси-конфигураторов, которые могут завернуть его в Проксю, а то и в несколько слоев. В Спринге они все обычно коллапсятся в один (хотя бывают случаи, когда прокся в проксе). И в конечном итоге мы возвращаем объект, который наш контекст еще и закеширует, если это синглетон.

Выводы такие: если что-то реально важно понять на всю жизнь - надо попробовать сделать что-то похожее самостоятельно. Тогда мы поставим себя на место того человека, который создавал технологию, которую мы хотим изучить. Поймем, какие при этом возникали дилемы, проблемы, и будет намного более понятно, и пользоваться этим фреймворком будем намного инуитивнее,
если мы уже пытались продумать его сами.