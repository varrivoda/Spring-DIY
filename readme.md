Это - конспект доклада Евгения Борисова "Спринг-построитель" на онлайн-конференции JUG.RU от 17 мая 2020г.
Запись находится по адресу https://www.youtube.com/watch?v=rd6wxPzXQvo

#Введение

Цель данной работы - поближе познакомиться со Спрингом, получить понятия об основных концепциях IoC, посмотреть как работает Спринг изнутри.

Для этого напишем приложение "CoronaDesinfector".
В процессе написания возникнет необходимость написать инфраструктуру, которая позволит переиспользовать код, сделает код гибким. 
И, самое главное, поможет нам соблюсти все правила SOLID.
При дальннейшем развитии этой инфраструктуры у нас появится фреймворк, очень похожий  на Спринг.
Это поможет лучше понять Спринг не только как пользователь, но и как создатель.

Пишем на Java 11. Зависимости:
jsr-250 для аннотации PostConstruct,  
lombok для экономии времени
org.reflections - расширение стандартной Рефлекшн-Api
(в конце добавится CGLib)

*****
# Часть 1. Основные классы по ТЗ
Создадим 2 класса,  
    CoronaDesinfector
    Room

Дезинфектор по ТЗ выполоняет 4 действия:
    - Делает объявление, что сейчас начнется дезинфекция, всем покинуть помещение
    - Всем, кто не вышел сам, поможет полицейский
    - Собственно, дезинфекция
    - Объявление, что можно зайти обратно

Объявления будет делать специальный класс Announcer. 
Но на случай если мы захотим сделать разные виды объявлений, 
лучше сделаем интерфейс Announcer с методом announce(), и его реализацию ConsoleAnnouncer 

Полицейский тоже будет интерфейсом Policeman с методом makePeopleLeaveRoom(), 
и реализацией PolicemanImpl

в Дезинфекторе сделаем поля типа Полицейский и Анонсер, 
и назначим им по новому объекту соответствующих имплементаций.

в Main создадим экземпляр Дезинфектора и вызовем метод desinfect()
...Проверяем, все работает.

*****
# ЧАСТЬ 2. Cчитаем ответственности класса Дезинфектор.

Казалось бы, наш Дезинфектор отвечает только за дезинфекцию
Однако если присмотреться, single responsibility тут и не пахнет:
на данный момент у этого класса более 7 ответственностей

Кроме методов start() и desinfect() у нас тут 2 поля Announcer и Policeman, которые создаются здесь же. Annoouncer - это интерфейс, и, возможно, в будущем появятся и другие его имплементации. То есть класс CoronaDesinfector принимает решение, что именно ConsoleAnnouncer должен быть использован в качестве Announcer для данного приложения. Сейчас это решение захардкожено, но если появится логика, по которой нужно будет выбрать подходящую имплементацию, то вся эта логика будет находиться здесь же. Например, идет в ENVIRONMENT_VARIABLE смотрит locale чтобы узнать, в какой стране находится компьютер, на котором запущено наше приложение. Чтобы в зависимости от этого выбрать нужную имплементацию, которая говорит на нужном языке и в соответствии с законами и правилами этой страны. А это уже не имеет никакого отношения к дезинфекции.

Третья ответственностль - наш Дезинфектор также должен поимать, как именно должен создаваться Анонсер: сегодня это просто пустой корнструктор, а завтра этот конструктор поменяют и т.д. И придется пререписывать также и Дезинфектор.

- А еще наш Дезинфектор должен уметь настроить Анонсер.
  В данный момент это не требуется, но если завтра ConsoleAnnouncer обрастет пропертями (например, громкость)
  и их надо будет настраивать при помощи сеттеров и т.д... В этом случае ответственность за настройку лолжится на Дезинфектор.

Все то же самое касается и Полисмена.
Итого всего 7 ответственностей. И если завтра появится другая имплементация Анонсера, то нам нужно знать все то же самое про неё...

Если подытожить, нашему дезинфектору нужно
1) дезинфицирповать
2) уметь создавать объекты

А кто будет решать,каккая имплементация?  ...чуть окунемся в историю.
Раньше не было Contineous Delivery, и никто не заморачивался с поддержкой кода и версиями.
...
Потом появился паттерн Фабрика: AnnouncerFactory
и на каждый чих-пых писали свою фабрику:
PolicemanFactory, DesinfectorFactory..... FactoryFactory :)
..не годится.

# Часть 3. ObjectFactory

В дальнейшем вместо "new..." стали new писать синглетон ObjectFactory на все случаи жизни (тогда люди ещё не понимали, что синглетон это антипаттерн... см далее) 
Это еще не Spring, но его предтеча, поэтому и мы напишем ObjectFactory.

Создаем "домашний синглетон" (т.е. самописный) ObjectFactory:
    private static ObjectFactory $$instance = new ObjectFactory();

Добавим метод <T> T createObject (Class<T> type)
и теперь в Дезинфекторе вместо new Announcer() пишем
    ObjectFactory.getInstance().createObject(Announcer.class)

По сравнению с тем, что было, это выглялит замечательно, т.к. Дезинфектор не знает ничего конкретного ни про Анонсера, ни про Полисмена. Он знает, что они ему нужны Анонсер и Полисмен - но это интерфейсы. Он не знает, какая имплементация, как настроить и т.д. Об этом заботится Фабрика.

Но. В большинстве случаев в метод createObject(type) будет прилетать не конкретный класс, а интерфнйс. Поэтому надо сделать проверку....

    //в начале присвоим type - на случай, если нам приходит не интерфейс, а конкретный класс:
    Class<? extends T> implClass = type;

    //дальше проверка: если этот тип явл интерфейсом...
    if(type.isInterface()){ 

        //...то надо заменить. А на что?
        implClass = ???
            //....у кого мы можем это спросить?
            // Согласно SRP, Фабрика не должна отвечать за конфигурацию

            // Для этого сделаем специальный класс Config
            config.getImplClass(type);
    }

..., и если передали интерфейс, то достать тип из Конфига.

Cоздадим классы Конфиг (интерфейс0, и имплементацию JavaConfig. Он должен уметь получить type который скорее всего будет интерфейсом, и вернуть имплементацию. Предположим, что у нас только одна имплементация интерфейса на приложение. Идея такая: мы пишем приложение,которым будут пользоваться разные клиенты. Но на этапе сборки мы подложим jar, в котором могут быть имплементации, подходящие для одного конкретного клиента.
И когда все собирается, имплементация всегда одна - пока будем исходить из этого.

Для этого используем объект класса Reflections из пакета org.reflections
- он существенно расширяет возможности стандартного рефлекшна, а также отлично подходит для расширения стандартных возможностей Спринга.

Создается он через new Reflections(String packageToScan). Пакет для сканирования получим в виде строки
из конструктора Конфига.

Теперь каждый раз, когда Конфиг просят дать имплементацию какого-то интерфейса, используем метод 
    getSubTypesOf(ifc)
и если classes.size()!=1, то есть либо импл нет, либо больше одной
то продолжать не можем, бросаем ексепшн, а если проскочили этот if, то возвращаем 
    classes.iterator().next(); 

...всё, пока что Конфиг будет работать так.

Возвращаемся в ObjectFactory, там мы должны настроить наш конфиг, пока что - при создании захардкодим наш пакет (com.example)
    Config config = new JavaConfig("com.example");
А потом это не будет захардкожено, а будет приходить от человека, который создает контексты и прочие вещи

...запускаем, все работает.

# ЧАСТЬ 3.1 - улучшаем Фабрику: добавляем Мапу, в которую кешируем имплементации

...Теперь попробуемсоздать новую имплементацию Полисмена - AngryPoliceman.
Как и ожидалось, срабатывает условие "ноль или более одной имплементации"

Чтобы задать коркрктную имплементацию из нескольких, заведём в конфиге Мапу (или Мультимап, если в будущем захотим поддерживать множественные имплементации)

    private Map <Class, Class> ifcToClassImpl;

добавим в конструктор, и теперь в getImplClassaType() мы можем не бежать сканировать пакеты... Но сначала бы неплохо посмотреть в Мапе. В java 9 появилсся замечательный метод Map.computeIfAbsent()
Он принимает ключ, и если такой ключ существует, то возвращет значение по этому ключу.
Если ключа нет, то запускает лямбду, которая в конечном итоге возвращает значение,
которое засетится в Мапу на будущее, и заодно вернется к нам.


    ifcToClassImpl.computeIfAbsent(ifc, aClass -> {
        //эталямбдабудет запускаться в тот момент, когда в Мапе ничего (?) нет
    }); 
    кстати,поставим спереди return

Также с помощью этой Мапы мы экономим системные ресурсы, т к сканирование это дорогой процесс, и если мы уже один раз просканировали, то второй раз не придется искать.

вернемся в ObjectFactory - там у нас сломался вызов конструктора Конфига. Перенесем инициализацию в конструктор
    new JavaConfig("com.epam", new HashMap<>(Map.of(Policeman.class, AngryPoliceman.class)>))

на самом деле этот код в будущем не будет сидеть здесь
- эта мапа может строиться из какого-то внешнего конфигурационного файла -
  скрипта, xml. Который мы можем просканировать в рантайме, и построить эту мапу из информации,
  написанной в текстовом режиме.
  А если завтра мы захотим поменят имплементацию -
  например для тестов, или другого клиента -
  нам не придется чинить код.
  Просто подправим конфигурационный файл, из которого строится мапа

...запускаем,все работает

# ЧАСТЬ 4, настройка объектов, часть 1

Итак. У нас появилось централизованное место для создания всех объектов. Если мы заохтим подменить имплементацию, то поменяем класс, например, обратно на PolicemanImpl, запускаем - отрабатывает старый Полицейский. Причём это не изменения в коде, а изменения в конфигурации. Да, сейчас пока мы изменяем конфигурацию внутри, но в будущем мы выненсем ее наружу. Мы будем передавать конфигурационный файл, который будет считан в рантайме, и эта Мапа построится в рантайме.


Второй плюс- перед тем как Фабрика отдаст объект, она может его настроить согласно нашим конвенциям, которые мы придумкем в будущем:
-делать какие-то инжекшены,
-проксировать классы,
-делать транзакции,
-делать какое-то ООП...
..и много разной другой магии с объектом.

4.1 Для этого в методе createObject() отделим создание нового экземпляра и return

Для демонстрации полезной настройки разберем пример: 
Мы хотим чтобы каждый раз, когда ConsoleAnouncer выводит сообщение, он выводил еще и рекламу.
для этого заведем в нем Рекомендатор:
    Recommendator recommendator = ObjectFactory.getInstance().createObject()

4.2 Создадим интерфейс Рекомендатор с методом recommend, а также напишем реализацию RecommendatorImpl
Метод recommend() будет выводить строчку "для защиты от Короны пейте " + alcohol,
где alcohol - строка в RecommendatorImpl, которую мы хотим задавать при создании
пометим alcohol аннотацией @InjectProperty()
(аналог @Value в Спринге)
-здесь мы сделаем так, чтобы можно либо указать имя проперти которую надо инжектить,
-либо если имя не указано, то название поля будет именем этой проперти

4.3 Создадим класс этой новой аннотации, в ней можно будет задать value, но по дефолту ""

4.4 Теперь идем в Ресурсы и создаем файл application.properties (также как в Спринге)
добавим туда alcohol=beer corona

4.5. В ConsoleAnnouncer в метод announce добавляем вызов recommendator.recommend();

...проверяеем...
и получаем рекомендацию - пить Null
потому чтомы не написали парсер файла пропертей

# ЧАСТЬ 5. Парсер пропертей
(пока что навалим все в кучу, а потом отрефкторим)

**
итак, мы разделили создание объекта  и return. Перед тем как наша фабрика вернет объект, она должна его настроить. Т.е после того как объект создан (но перед тем как его вернуть), нам надо посмотреть - а нет ли у него каких-то полей, в которые мы моглибы заинжектить какие-то проперти. Без рефлексии не обойтись...

    implClass.getDeclaredFields()
    //по-хорошему надо найти также и поля родителя
    // а для этого нужна рекурсия или польз-ся какими-то ReflectionUtils
    // но сейчас для простоты сделаем без учета наследования

и для каждого филда попытаемся считать аннотацию
    
    Field field : implClass.getDeclaredFields()) {
        field.getAnnotation(InjectProperty.class);
        if(annotation!=null){
            if(annotation.value().isEmpty()){
                ..вытащить из файла проперти по названию поля 
            }
        }

**нам понадобится Мапа из файла проперти
**пишем парсер файла проперти

в цикле перебора полей -см выше- получим доступ к пропертиз
ClassLoader.getSystemClassLoader().getResources("application.properties")
в будущем мы можем усовершенствовать это,
и указывать также и доп файлы пропертей...хотя зачем?
в Спринге он читается автоматически, и всепро это знают

...берем Stream lines = BufferedReader(new FileReader(path из класслоадера)).lines()
lines.map(line->line.split("=").collect(toMap(arr->arr[0], arr->arr[1])))
это возвращает Map<String,String> propertiesMap =
и теперь отсюда мы можем доставать пропертис, если value в аннотации был пустой,
и вставлять их в строку

    String value;
    if ... {
        value= propertiesMap.get(field.getName());
    } else{
        valuie = propertiesMap.get(annotatipn.value())   
    }
можно сделать в виде тернарного оператора ("Элвиса" :)

Если value в аннотации было пустое, то мы берем имя поля. А если значнеие было, берем его. Таким образом из мапы берем значение, которое нужно засетить. Правда, field скоорее всего привате, поэтому надосделать setAccessible(true), потом field.set (t, value)

..проверяем, работает. Но!
//таймкод 54:00
