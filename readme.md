Это - конспект доклада Евгения Борисова "Спринг-построитель" на онлайн-конференции JUG.RU от 17 мая 2020г.
Запись находится по адресу https://www.youtube.com/watch?v=rd6wxPzXQvo

#Введение

Цель данной работы - поближе познакомиться со Спрингом, получить понятия об основных концепциях IoC, посмотреть как работает Спринг изнутри.

Для этого напишем приложение "CoronaDesinfector".
В процессе написания возникнет необходимость написать инфраструктуру, которая позволит переиспользовать код, сделает код гибким. 
И, самое главное, поможет нам соблюсти все правила SOLID.
При дальннейшем развитии этой инфраструктуры у нас появится фреймворк, очень похожий  на Спринг.
Это поможет лучше понять Спринг не только как пользователь, но и как создатель.

Пишем на Java 11. Зависимости:
jsr-250 для аннотации PostConstruct,  
lombok для экономии времени
org.reflections - расширение стандартной Рефлекшн-Api
(в конце добавится CGLib)

*****
# Часть 1. Основные классы по ТЗ
Создадим 2 класса,  
    CoronaDesinfector
    Room

Дезинфектор по ТЗ выполоняет 4 действия:
    - Делает объявление, что сейчас начнется дезинфекция, всем покинуть помещение
    - Всем, кто не вышел сам, поможет полицейский
    - Собственно, дезинфекция
    - Объявление, что можно зайти обратно

Объявления будет делать специальный класс Announcer. 
Но на случай если мы захотим сделать разные виды объявлений, 
лучше сделаем интерфейс Announcer с методом announce(), и его реализацию ConsoleAnnouncer 

Полицейский тоже будет интерфейсом Policeman с методом makePeopleLeaveRoom(), 
и реализацией PolicemanImpl

в Дезинфекторе сделаем поля типа Полицейский и Анонсер, 
и назначим им по новому объекту соответствующих имплементаций.

в Main создадим экземпляр Дезинфектора и вызовем метод desinfect()
...Проверяем, все работает.

*****
# ЧАСТЬ 2. Cчитаем ответственности класса Дезинфектор.

Казалось бы, наш Дезинфектор отвечает только за дезинфекцию
Однако если присмотреться, single responsibility тут и не пахнет:
на данный момент у этого класса более 7 ответственностей

Кроме методов start() и desinfect() у нас тут 2 поля Announcer и Policeman, которые создаются здесь же. Annoouncer - это интерфейс, и, возможно, в будущем появятся и другие его имплементации. То есть класс CoronaDesinfector принимает решение, что именно ConsoleAnnouncer должен быть использован в качестве Announcer для данного приложения. Сейчас это решение захардкожено, но если появится логика, по которой нужно будет выбрать подходящую имплементацию, то вся эта логика будет находиться здесь же. Например, идет в ENVIRONMENT_VARIABLE смотрит locale чтобы узнать, в какой стране находится компьютер, на котором запущено наше приложение. Чтобы в зависимости от этого выбрать нужную имплементацию, которая говорит на нужном языке и в соответствии с законами и правилами этой страны. А это уже не имеет никакого отношения к дезинфекции.

Третья ответственностль - наш Дезинфектор также должен поимать, как именно должен создаваться Анонсер: сегодня это просто пустой корнструктор, а завтра этот конструктор поменяют и т.д. И придется пререписывать также и Дезинфектор.

- А еще наш Дезинфектор должен уметь настроить Анонсер.
  В данный момент это не требуется, но если завтра ConsoleAnnouncer обрастет пропертями (например, громкость)
  и их надо будет настраивать при помощи сеттеров и т.д... В этом случае ответственность за настройку лолжится на Дезинфектор.

Все то же самое касается и Полисмена.
Итого всего 7 ответственностей. И если завтра появится другая имплементация Анонсера, то нам нужно знать все то же самое про неё...

Если подытожить, нашему дезинфектору нужно
1) дезинфицирповать
2) уметь создавать объекты

А кто будет решать,каккая имплементация?  ...чуть окунемся в историю.
Раньше не было Contineous Delivery, и никто не заморачивался с поддержкой кода и версиями.
...
Потом появился паттерн Фабрика: AnnouncerFactory
и на каждый чих-пых писали свою фабрику:
PolicemanFactory, DesinfectorFactory..... FactoryFactory :)
..не годится.

# Часть 3. ObjectFactory

В дальнейшем вместо "new..." стали new писать синглетон ObjectFactory на все случаи жизни (тогда люди ещё не понимали, что синглетон это антипаттерн... см далее) 
Это еще не Spring, но его предтеча, поэтому и мы напишем ObjectFactory.

Создаем "домашний синглетон" (т.е. самописный) ObjectFactory:
    private static ObjectFactory $$instance = new ObjectFactory();

Добавим метод <T> T createObject (Class<T> type)
и теперь в Дезинфекторе вместо new Announcer() пишем
    ObjectFactory.getInstance().createObject(Announcer.class)

По сравнению с тем, что было, это выглялит замечательно, т.к. Дезинфектор не знает ничего конкретного ни про Анонсера, ни про Полисмена. Он знает, что они ему нужны Анонсер и Полисмен - но это интерфейсы. Он не знает, какая имплементация, как настроить и т.д. Об этом заботится Фабрика.

Но. В большинстве случаев в метод createObject(type) будет прилетать не конкретный класс, а интерфнйс. Поэтому надо сделать проверку....

    //в начале присвоим type - на случай, если нам приходит не интерфейс, а конкретный класс:
    Class<? extends T> implClass = type;

    //дальше проверка: если этот тип явл интерфейсом...
    if(type.isInterface()){ 

        //...то надо заменить. А на что?
        implClass = ???
            //....у кого мы можем это спросить?
            // Согласно SRP, Фабрика не должна отвечать за конфигурацию

            // Для этого сделаем специальный класс Config
            config.getImplClass(type);
    }

..., и если передали интерфейс, то достать тип из Конфига.

Cоздадим классы Конфиг (интерфейс0, и имплементацию JavaConfig. Он должен уметь получить type который скорее всего будет интерфейсом, и вернуть имплементацию. Предположим, что у нас только одна имплементация интерфейса на приложение. Идея такая: мы пишем приложение,которым будут пользоваться разные клиенты. Но на этапе сборки мы подложим jar, в котором могут быть имплементации, подходящие для одного конкретного клиента.
И когда все собирается, имплементация всегда одна - пока будем исходить из этого.

Для этого используем объект класса Reflections из пакета org.reflections
- он существенно расширяет возможности стандартного рефлекшна, а также отлично подходит для расширения стандартных возможностей Спринга.

Создается он через new Reflections(String packageToScan). Пакет для сканирования получим в виде строки
из конструктора Конфига.

Теперь каждый раз, когда Конфиг просят дать имплементацию какого-то интерфейса, используем метод 
    getSubTypesOf(ifc)
и если classes.size()!=1, то есть либо импл нет, либо больше одной
то продолжать не можем, бросаем ексепшн, а если проскочили этот if, то возвращаем 
    classes.iterator().next(); 

...всё, пока что Конфиг будет работать так.

Возвращаемся в ObjectFactory, там мы должны настроить наш конфиг, пока что - при создании захардкодим наш пакет (com.example)
    Config config = new JavaConfig("com.example");
А потом это не будет захардкожено, а будет приходить от человека, который создает контексты и прочие вещи

...запускаем, все работает.

# ЧАСТЬ 3.1 - улучшаем Фабрику: добавляем Мапу, в которую кешируем имплементации

...Теперь попробуемсоздать новую имплементацию Полисмена - AngryPoliceman.
Как и ожидалось, срабатывает условие "ноль или более одной имплементации"

Чтобы задать коркрктную имплементацию из нескольких, заведём в конфиге Мапу (или Мультимап, если в будущем захотим поддерживать множественные имплементации)

    private Map <Class, Class> ifcToClassImpl;

добавим в конструктор, и теперь в getImplClassaType() мы можем не бежать сканировать пакеты... Но сначала бы неплохо посмотреть в Мапе. В java 9 появилсся замечательный метод Map.computeIfAbsent()
Он принимает ключ, и если такой ключ существует, то возвращет значение по этому ключу.
Если ключа нет, то запускает лямбду, которая в конечном итоге возвращает значение,
которое засетится в Мапу на будущее, и заодно вернется к нам.


    ifcToClassImpl.computeIfAbsent(ifc, aClass -> {
        //эталямбдабудет запускаться в тот момент, когда в Мапе ничего (?) нет
    }); 
    кстати,поставим спереди return

Также с помощью этой Мапы мы экономим системные ресурсы, т к сканирование это дорогой процесс, и если мы уже один раз просканировали, то второй раз не придется искать.

вернемся в ObjectFactory - там у нас сломался вызов конструктора Конфига. Перенесем инициализацию в конструктор
    new JavaConfig("com.epam", new HashMap<>(Map.of(Policeman.class, AngryPoliceman.class)>))

на самом деле этот код в будущем не будет сидеть здесь
- эта мапа может строиться из какого-то внешнего конфигурационного файла -
  скрипта, xml. Который мы можем просканировать в рантайме, и построить эту мапу из информации,
  написанной в текстовом режиме.
  А если завтра мы захотим поменят имплементацию -
  например для тестов, или другого клиента -
  нам не придется чинить код.
  Просто подправим конфигурационный файл, из которого строится мапа

...запускаем,все работает

# ЧАСТЬ 4, настройка объектов, часть 1

Итак. У нас появилось централизованное место для создания всех объектов. Если мы заохтим подменить имплементацию, то поменяем класс, например, обратно на PolicemanImpl, запускаем - отрабатывает старый Полицейский. Причём это не изменения в коде, а изменения в конфигурации. Да, сейчас пока мы изменяем конфигурацию внутри, но в будущем мы выненсем ее наружу. Мы будем передавать конфигурационный файл, который будет считан в рантайме, и эта Мапа построится в рантайме.


Второй плюс- перед тем как Фабрика отдаст объект, она может его настроить согласно нашим конвенциям, которые мы придумкем в будущем:
-делать какие-то инжекшены,
-проксировать классы,
-делать транзакции,
-делать какое-то ООП...
..и много разной другой магии с объектом.

4.1 Для этого в методе createObject() отделим создание нового экземпляра и return

Для демонстрации полезной настройки разберем пример: 
Мы хотим чтобы каждый раз, когда ConsoleAnouncer выводит сообщение, он выводил еще и рекламу.
для этого заведем в нем Рекомендатор:
    Recommendator recommendator = ObjectFactory.getInstance().createObject()

4.2 Создадим интерфейс Рекомендатор с методом recommend, а также напишем реализацию RecommendatorImpl
Метод recommend() будет выводить строчку "для защиты от Короны пейте " + alcohol,
где alcohol - строка в RecommendatorImpl, которую мы хотим задавать при создании
пометим alcohol аннотацией @InjectProperty()
(аналог @Value в Спринге)
-здесь мы сделаем так, чтобы можно либо указать имя проперти которую надо инжектить,
-либо если имя не указано, то название поля будет именем этой проперти

4.3 Создадим класс этой новой аннотации, в ней можно будет задать value, но по дефолту ""

4.4 Теперь идем в Ресурсы и создаем файл application.properties (также как в Спринге)
добавим туда alcohol=beer corona

4.5. В ConsoleAnnouncer в метод announce добавляем вызов recommendator.recommend();

...проверяеем...
и получаем рекомендацию - пить Null
потому чтомы не написали парсер файла пропертей

# ЧАСТЬ 5. Парсер пропертей
(пока что навалим все в кучу, а потом отрефкторим)

**
итак, мы разделили создание объекта  и return. Перед тем как наша фабрика вернет объект, она должна его настроить. Т.е после того как объект создан (но перед тем как его вернуть), нам надо посмотреть - а нет ли у него каких-то полей, в которые мы моглибы заинжектить какие-то проперти. Без рефлексии не обойтись...

    implClass.getDeclaredFields()
    //по-хорошему надо найти также и поля родителя
    // а для этого нужна рекурсия или польз-ся какими-то ReflectionUtils
    // но сейчас для простоты сделаем без учета наследования

и для каждого филда попытаемся считать аннотацию
    
    Field field : implClass.getDeclaredFields()) {
        field.getAnnotation(InjectProperty.class);
        if(annotation!=null){
            if(annotation.value().isEmpty()){
                ..вытащить из файла проперти по названию поля 
            }
        }

**нам понадобится Мапа из файла проперти
**пишем парсер файла проперти

в цикле перебора полей -см выше- получим доступ к пропертиз
ClassLoader.getSystemClassLoader().getResources("application.properties")
в будущем мы можем усовершенствовать это,
и указывать также и доп файлы пропертей...хотя зачем?
в Спринге он читается автоматически, и всепро это знают

...берем Stream lines = BufferedReader(new FileReader(path из класслоадера)).lines()
lines.map(line->line.split("=").collect(toMap(arr->arr[0], arr->arr[1])))
это возвращает Map<String,String> propertiesMap =
и теперь отсюда мы можем доставать пропертис, если value в аннотации был пустой,
и вставлять их в строку

    String value;
    if ... {
        value= propertiesMap.get(field.getName());
    } else{
        valuie = propertiesMap.get(annotatipn.value())   
    }
можно сделать в виде тернарного оператора ("Элвис" :)

Если value в аннотации было пустое, то мы берем имя поля. А если значнеие было, берем его. Таким образом из мапы берем значение, которое нужно засетить. Правда, field скоорее всего привате, поэтому надосделать setAccessible(true), потом field.set (t, value)

..проверяем, работает, но...
//таймкод 54:00

# ЧАСТЬ 6 Рефактоирим Мапу и InjectProperty

..но. Некравсиво написан код: каждый раз читать проперти файл... Ну и вообще, страшно представить, что будет с фабрикой через несколько лет. Сегодня мы инжектим поля, завтра объекты, потом @Async, @Scheduled, @Transactional, @....,
и во всех них будем постоянно проверять и перебирать if'ы? Фабрика раздуется до тысяч строк, и другим людям придется допиливать вручную из сорсов...

В SOLID "O" означает открыто к дополнениям, закрыто для модификации. Если мы хотим дописать функционал, это не должно приводить к изменениям того, что уже написано. Сейчас наше "O" сломано: класс надо дописывать, и он никогда не будет "Close". А сломано оно потому что сломано "S" - single responsibillity. Они обычно ломаются вместе. Внашем случае - потому что Фабрика должна отвечать только за создание объекта, а у нас она также делает и его настройку. 

1. Настраивать надо в другом месте, поэтому делаем новый тип ObjectConfigurator (в Спринге это BeanPostprocessor). Это интерфейс, т.к. конфигураторов будет много: на каждую аннотацию, конвенцию, каждую дополнительную настройку
будет свой конфигуратор. У всех их есть метод configure(), который принимает Object t, не смотря на то, откуда он пришел, т к по его респоносибиолити не важно знать, откуда он пришел, и откуда он появился.

2. напишем его имплемментацию с длинным названием
    InjectPropertyAnnotaionObjectConfigurator
, и встатвим сюда логику из ObjectFactory. Правда нам откуда-то надо взять implClass - возьмем его из нашего объекта
    t.getClass()
(поставим @SneakyThrows)

3. Естественно что мапа не должна строиться каждый раз. Построим её один раз в конструкторе
Вспормогательные path, lines, на них propertiesMap.. А сама мапа должна быть филдом (иначе "пейте null")

итого, когда создастся Конфигуратор, он один раз просетит мапу.
и когда его попросят сконфигурировать объект, он будет смотреть -
а нету ли у полей данного объекта аннотации @injectPrerty?
и если есть, то будет доставать из propertyMap нужное значение для даной проперти
и сетить его в филд

осталось подружить ObjectFactory с Конфигураторами
4. в Фабрике: поле    private List<Configurator> configurators = new ArrayList<>();
как проинициализировать? чтобы не приходилось каждый раз куда-то прописывать эти Конфигураторы,
было бы неплохо просканировать наш пакет на предмет имплементаций Конфигураторов, точно также как мы сканируем имплементации для наших интерфейсов. А затем всехих учесть и сложть в Лист.

поэтому было бы неплохо,чтобы наш Конфиг умел отдавать Сканер
5.(делаем геттер в интерфейсе [через Refactor-Pull members up])
теперь наш Конфиг умеет не только говорить, какая имплементация, но и отдать Сканер, если какая-н инфраструктурная штука захочнт его получить. Причем этот сканер уже настроен: в Фабрику пришел готовый Конфиг. И когда этот Конфиг создается, он настраиваеи этот сканер на тот пакет, который попросили. И теперь этот настроеный сканер можнов любой момент получить

теперь наша ObjectFactory говорит: давайте у Конфига возьмеме Сканер, возьмем все подвиды ОбжектКонфигураторов, проитерируемся по ним (хорошо бы проверять,не абстрактный ли класс, но не сейчас)
    configurators.add(aClass.getDeclaratedConstructor().newInstance())

проверяем:
пейте null
(может выпасть, если не проинициализировалась Мапа; у меня было из-за того, что она пересоздавалась в конструкторе) 

Нет, забыли самое главное.
Мы проиниц лист конфигураторов, и в самом начале заполнили его. Но мы им нигде не пользуемся. Поэтому после создания объекта мы попросим каждый из конфигураторов настроить наш объект:
    configurators.forEach(objectCongfigurator->objectCpnfigurator.configure(t));

Это разновидность дизайн-паттерна "Chain of Responsibility": вместо того чтобы постоянно нарушать Open/Closed principle и постоянно добавлять логику, которая хэндлит какой-то объект, у нас есть много разных хэндлеров - в нашем случае Конфигураторов. И они автоматически добавляются в наш лист, и каждый имеет возможность настроить объект. Какие-то изних ничего не сделают, тк у объекта нет тех аннотаций, который они будут искать

И даже если какой-то объект совсем не надо настраивать, все равно мы можем без проблем протащить его хоть через 30 конфигураторов, т к большиснство объектов будут создаваться в начале (большинство изних - синглетоны). Поэтому на перформанс не сильно повлияет. А даже если и чуть-чуть повлияет, то на бутстрапе. А в рантайме, когда все объекты будут настроены и будут работать друг с другом, это вообще никак не затронет. Когда Дезинфектор работает, никакие фабрики не работают, он настроен и мы им пользуемся.

...проверяем, все работает.
>Корона бир, *реклама

...добавим в Пропертиз whisky=singleton
Пока мы не указали, какое проперти мы хотим заинжектить, будет то же самое. Решающим является название филда
филд "алкоголь" поэтому пропертиназ-ся "алкоголь",а в этом проперти сидит "корона бир"
если мы скажем @InkectProperty("whisky") то проинжектится проперти с этим именем

//таймкод 1:06:50
Промежуточные итоги: у нас есть централизованноеметсо длясощданиея объектов - Фабрика
Еслимыхотим помиенятьимплементаци,нам не надолезть в код
Если мы зотим чтобы объект приходил настроенным, мы модждем обучить Aff,hbre настроить нашлобъект согласноконвенциям типа "PropertySource"(?) ой то есть @InjectPropertyи т.д.
Мы сможем кэшировать синглетоны (пока не реализовано). Поскольку больштнство объектов от Фабрики - необъекты типа Person, аобхъектфы типа PersonService (сервисы, репозитории,контроллеры ит.д.) и эти сервисы в 99% слуячаевнудныв единстввенном экземпляре. Соответственно,их моженозакэшировать... Чем сейчас и займемся.

# ЧАСТЬ 7 Почему "домашний синглетон" это плохо?
(небольшая философская вставка)

Есть дата-объекты, они никогда не менеджатся таким фреймворком как Фабрика. Они менеджатся всякими Hibernate, Spring Data ит.д. Они никогда не бывают синглетонами, они постоянно создаются и наполняются разными данными из базы или по REST... 

А есть объекты, которые типа "сервисы", и эти сервисы лучше всего делать, что называется, "stateless". Это слово не означает, что у них нет стейта. "Stateless" означает, что когда сервис настроился - посредством конструктора, или сеттером, или проинжектили с помощью фреймворка - то потом его стейт уже не будет меняться. В таком случае их можно сделать синглетонами. Потому что мы можем не думать о том, что произойдет, если мой синглетон изменит состоние.

Если мой объект функционален, в нем есть разные функционалттные методы, которыми можно пользоваться в разных точках - зачем его клонировать? К томуже, есть случаи, когда клонирование будет бить по перформансу. Не говоря уже о случаях, когдаэто может банадльно наорушть бизнес-логику. Например, объекты типа Cache или LoadBalancer - их просто нельзя делать больше, чем один экземпляр.... Практически все наши сервисы должны быть синглетонами, т.к. если у нас одним сервисом пользуются разные классы, никто не долженн думать о том, что - я вот сейчас вызываю метод, а вдруг кто-то другой тоже, пользуясь эти синглетоном, его переконфигурировал в процессе? И у меня в процессе вызова что-то поменялось... Поэтому, если объект Stateless, я не должен думать про синхронизыцию, lock'и, и не придется его клонировать.  Поэтому Slateless нужно делать синглетоном.

...вернемся в наш CoronaDesinfector. 
Он не идеален,в первую очередь из-за части с getInstance() (Автор называет это Доашний Синглетон)
//таймкод 1:11:50
Когда кто-то хочет что-то получить от фабрики (а у нас Все хотят что-то получить от фабрики)
Что произойдетесли вдруг мызахотим переехать с Lomboka и декларировать эксепшены вместо @SneakyThrowws?
Все сломается.

Проблема №2. Хотим написат юнит-тест на CoronaDesinnfector.start() 
замокаем Анонсер ,Полисмена и т.д. (через Рефлекшнс) - но когда тест сделает new CoronaDesinfector(), в этот же момент дернется ObjectFactory.getInstance(), не смотря на то что мы мокаем наши поля, потому что перед конструктором отработают ^инлайны. То есть создастся Фабрика (при чем долго: вычитывает конфигурцию, сканирует пакеты, складываем в списки и мапы и т.д.). Но в работе это делается один раз. А вслучае с тестами это происходит при каждом тесте. Ну либо при помощи PowerMocka мокать getInstance()....а он работает еще медленнее,тк подменяет класслоадеры и пр.

Последний аргумент: мы говорили, что наша инфраструктура должна бы кэшировать снглетоны, т.к: "это классно, сервисы в большинствве должны быть синглетонами, все кто stateless должны быть синглетонами, нахрена плодить объекты, если можно  пользоваться одними и теми же..." Но! Если мы будем реалтзовывать синглетон как в 2003 году.... (а примерно с 2005 он счиатется анти-паттерном) Так почему не надо писать синглетон руками? Почему "Домашний С" это плохо? 

Представим, что пишем приложение с цепочкой зависимостей: A<-B, B<-C, C<-D и все они синглетоны, и вызывают друг друга через getInstance(). Вопрос: как будем тестировать? Никак, т к создание сервиса A притянет сервис B, который притянет сервис C, все это захардкожено... имеем длинный каплинг при помощи статических методов, взамен которых ничего не подложишь. Поэтому Синглетон это антипаттерн. Синглетон это хорошо, но Синглетон это плохо.

Поэтому, вместо того чтобы клонировать наше решение с getInstance() по всем классам и отказываться от фабрики, давайте наоборот - научим нашу инфрастркуктуру кэшировать все синглетоны.